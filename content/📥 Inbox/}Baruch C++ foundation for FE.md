---
tags: üß†Ô∏è/üì•Ô∏è/üèõÔ∏è/üü•Ô∏è
source: 
publish: true
parent: 
aliases: 
type: course
status: üü•
---

Related: 
URL: <https://mfe.baruch.cuny.edu/online-programming/>






### Syllabus in bulletpoints


- #### part I : basics
	* The C++ Environment
		* History of C++2
		* What Makes a C++ Program
		* Steps for a C++ Program
		* Compiling a C++ Program
		- Structure of a C++ Source
		- Example Program
		- Placing Comments
		- Lay-Out Source File
		- The Visual Studio IDE explained
		- C++ for computational finance: an overview
	- Data types
		- Fundamental Data Types
		- Type Magnitudes
		- Type Specifiers and Qualifiers
		- Constants
	- Variables, Operators and Expressions
		- Variables
		- Initialising Variables
		- Concatenating Declarations
		- Arithmetic Operators
		- Special Cases
		- Relational Operators
		- Logical Operators
		- Assignment Operators
		- Increment and Decrement
		- Conditional Operator
		- The Comma Operator
		- Type Conversion The sizeof Operator
		- Bitwise Operators
		- Operator Precedence

	- **Decisions and Loops**
		- Blocks and Statements
		- If Else
		- Switch
		- For
		- While
		- Do While
		- Break and Continue
		- Goto and Labels
	- **Functions and Storage Classes**
		- Function Signatures
		- Function Calls
		- Functions and Return
		- Function Arguments
		- Recursive Functions3
		- Scope of variables
		- Automatic Variables
		- Global Variables
		- External Variables
		- Static Global Variables
		- Functions and Static Variables
		- Register Variables
	- **The Preprocessor**
		- Introduction to Directives
		- Include Files
		- Macros
		- Conditional Compilation
		- Header Files and Directives
	- **Pointers and Arrays**
		- Pointers
		- Call by Reference
		- Arrays
		- Initialising Arrays
		- Strings
		- Using Strings
		- Arrays and Pointers
		- Pointer Arithmetic
		- Multidimensional Arrays
		- Function pointers and their applications
	- **Data Aggregates**
		- Introduction to Structures
		- Using Structures
		- Arrays of Structures
		- Structures and Pointers
		- Passing Structures
		- Unions
		- Typedef







#### **Part II Object-Oriented Programming (OOP) in C++**

In this part of the course we introduce the object-oriented programming model and how to implement it in

C++. We focus on motivating on how to ‚Äòthinking objects‚Äô while at the same time avoiding going

overboard by creating over-engineered classes and class hierarchies. Since C++ is a huge language it is

often difficult for beginners to know where to begin and for this reason we concentrate on essential and

high-priority topics which when learned will allow you to write non-trivial C++ code in a short period of

time. The approach taken is incremental and this part of the course contains some of the most important

C++ features that you will use when developing your applications in computational finance, for example

public and private class members, use of the const keyword, operator overloading and efficient memory

allocation.4

Having successfully completed this part, you will have acquired a good knowledge of the C++ language

that is needed to create efficient and robust classes. In the next part of the course we shall incrementally

build on the methods here in order to create reusable and flexible class hierarchies.

The quizzes and exercises pertain to generic, numeric and financial examples and they test your knowledge

of intermediate-level functionality relating to the creation of classes and objects in C++.

**OOP Thinking and Modeling**

‚Ä¢ Classes and Objects; what are they?

‚Ä¢ Discovering classes

‚Ä¢ Encapsulation and implementation hiding

‚Ä¢ Class relationships: aggregation and composition

‚Ä¢ Class relationships: inheritance

‚Ä¢ A little UML (Unified Modeling Language)

‚Ä¢ Advantages and disadvantages of OOP

‚Ä¢ OOP in combination with other programming paradigms

**The Class Concept**

‚Ä¢ Abstract Data Types

‚Ä¢ Classes and Objects

‚Ä¢ C++ members

‚Ä¢ Constructors and destructors

‚Ä¢ The C++ header file

‚Ä¢ Access specifiers

‚Ä¢ The C++ source file

‚Ä¢ Creating objects

**Improving your Classes**

‚Ä¢ Function name overloading

‚Ä¢ Call by reference vs. call by value

‚Ä¢ The 'const' specifier

‚Ä¢ The copy constructor

**Basic Operator Overloading**

‚Ä¢ Introduction to operator overloading

‚Ä¢ Binary operators

‚Ä¢ Unary operators

‚Ä¢ Assignment operators

‚Ä¢ The 'this' pointer

‚Ä¢ Returning references

‚Ä¢ The Essential Header File

**Memory Management, Fundamentals**

‚Ä¢ Stack, heap and static memory

‚Ä¢ Who takes care of memory?

‚Ä¢ The _new_ and _delete_ operators5

‚Ä¢ Dynamic arrays

‚Ä¢ Classes with dynamic memory

‚Ä¢ Smart pointers

**Namespaces**

‚Ä¢ Why using namespaces

‚Ä¢ Using classes in a namespace

‚Ä¢ Placing classes in a namespace

‚Ä¢ Nested namespaces

‚Ä¢ Aliases

‚Ä¢ Name lookups

**Part III Inheritance and Polymorphism**

In this part of the course we discuss a number of advanced features that allow us to justify the remark that

C++ is an object-oriented language. In particular, we discuss how C++ realizes the

Generalization/Specialization (ISA) relationship by its support for the inheritance mechanism. We consider

both implementation and interface inheritance, how to implement them in C++ as well as the impact they

have on the quality of your software.

Having successfully completed this part, you will have acquired a good knowledge of the inheritance

mechanism in C++ in order create efficient and robust class hierarchies

The quizzes and exercises pertain to generic and financial examples and they test your knowledge of

advanced-level functionality relating to the creation of classes, class hierarchies and applications in C++.

**Object-Oriented Modeling**

‚Ä¢ Gen/Spec (ISA) relationship

‚Ä¢ The Principle of Substitutability

‚Ä¢ When to use ISA and when to use HASA

‚Ä¢ Combining ISA and HASA

‚Ä¢ Good and bad class hierarchies

‚Ä¢ A little UML (Unified Modeling Language)

**Simple Inheritance**

‚Ä¢ Inheritance and ISA Relationship

‚Ä¢ Specialisation scenarios

‚Ä¢ Inheritance and object creation

‚Ä¢ Using base class constructors

‚Ä¢ Accessibility of base members

‚Ä¢ Overriding functions

**Polymorphism**

‚Ä¢ Pointers to the base class

‚Ä¢ Function visibility

‚Ä¢ Polymorphism

‚Ä¢ Defining an interface

‚Ä¢ Abstract base classes6

‚Ä¢ Virtual destructors

‚Ä¢ Operator overloading and inheritance

**Exception Handling**

‚Ä¢ Error handling and exceptions

‚Ä¢ Throwing and catching exceptions

‚Ä¢ Exception hierarchy

‚Ä¢ Polymorphic and explicit nets

‚Ä¢ Order of handlers

**Final Remarks and Guidelines**

‚Ä¢ Semantic correctness of class hierarchies

‚Ä¢ Efficiency and maintainability issues

‚Ä¢ Too much inheritance considered harmful

‚Ä¢ What to use instead of multiple inheritance

**Part IV Generic Programming in C++ and Standard Template Library (STL)**

In this part we introduce the generic programming model and its realization by C++ template classes and

template functions. The GP model is probably not as well known as the OOP model but it is pervasive in

C++ and in a sense more important than OOP as can be seen in libraries such as STL (Standard Template

Library) and Boost. We can combine the OOP and GP models and they can also be seen as competitors for

solving a given problem.

It is possible to create template functions and classes based on the skills that you learned in Part III of the

course. We do consider creating our own templates but the main focus is on using ready-made template

data containers and algorithms.

Having successfully completed this part, you will have acquired a good knowledge of templates in C++ in

order to create compile-time efficient and robust generic classes and functions.

The quizzes and exercises pertain to generic and financial examples and they test your knowledge of

template classes and algorithms. In particular, eliminating and resolving compiler errors is an important

skill you need to learn.

**An Introduction to Generic Programming (GP)**

‚Ä¢ An introduction to generic programming

‚Ä¢ Abstract data types and algorithms

‚Ä¢ Generic polymorphism

‚Ä¢ Composition and inheritance in GP

‚Ä¢ Combining OOP and GP

‚Ä¢ GP and modular programming

**Template Classes in C++**

‚Ä¢ An introduction to C++ templates

‚Ä¢ Parameterization

‚Ä¢ Template classes and function templates

‚Ä¢ Creating templates (source & header files)

‚Ä¢ Type template parameter & value template parameter7

‚Ä¢ Operations on the generic argument

‚Ä¢ Explicit template instantiation

**An Introduction to STL**

‚Ä¢ The 6 STL component Categories

‚Ä¢ Sequential data containers

‚Ä¢ Iterators

‚Ä¢ Algorithms

‚Ä¢ Function objects

‚Ä¢ Using STL in your applications

**STL Containers and Algorithms**

‚Ä¢ An introduction to Complexity Analysis

‚Ä¢ Complex numbers in STL

‚Ä¢ Vectors and lists

‚Ä¢ Maps and sets

‚Ä¢ Modifying and nonmodifying algorithms

‚Ä¢ Numeric algorithms

**Combining OOP and GP**

‚Ä¢ GP with inheritance and composition

‚Ä¢ Template specialization

‚Ä¢ Integration with design patterns

‚Ä¢ Policy-based design and software contracts

‚Ä¢ Dynamic and parametric polymorphism

‚Ä¢ Efficiency and flexibility

**Part V An Introduction to Boost C++ Libraries**

For completeness and a wish to discuss ready-made C++ functionality in computational finance

applications we have decided to introduce a number of relevant libraries from the Boost suite of libraries.

In particular, we focus on those libraries that we directly use in applications in Part VI of the course. The

use of these libraries is similar to how libraries in Matlab and Fortran are employed in applications.

We focus on libraries that help us solve linear matrix systems, compute random numbers, special

mathematical functions and statistical distributions.

Having successfully completed this part, you will have acquired a basic knowledge of how to use the Boost

library.

There are no exercises in this Part V because they are incorporated into the exercises of Part VI.

**An Introduction to Boost C++ Libraries**

‚Ä¢ What is Boost? Overview

‚Ä¢ Matrix and Vectors: uBLAS library

‚Ä¢ Continuous and Discrete Statistical Distributions

‚Ä¢ Random number generation

‚Ä¢ Special function in Math Toolkit8

‚Ä¢ Solution of nonlinear equations

Some test code and examples can be found on www.datasimfinancial.com

**Part VI Creating Applications in Computational Finance**

Having completed the first five parts of the course we are now ready to start developing some applications

for computational finance. We take a number of well-known and well-documented examples from the

financial literature. The software _process_ in this part of the course is to take a financial model, set up the

numerical model and then implement it in C++. We take an incremental approach ‚Äú_get it working, then get_

_it right_, _then get it optimized_‚Äù (in that order and if time permits.) You will be expected to make use of STL

and Boost libraries to speed up productivity and to produce robust code.

Having successfully completed this part, you will have acquired a good knowledge of how to design and

implement simple applications in computational finance as well as learning how to approach and solve

software problems.

**Applications and Test Cases**

‚Ä¢ Black Scholes equation: analytic solution

‚Ä¢ A simple binomial method in C++

‚Ä¢ A one-factor Monte Carlo simulator

‚Ä¢ Using C++ numerical analysis libraries

‚Ä¢ Software design essentials

**Test Case 1 Monte Carlo Method**

‚Ä¢ Choose software framework

‚Ä¢ Random number generators

‚Ä¢ SDEs and Finite Difference approximations

‚Ä¢ Performance and accuracy

‚Ä¢ Some 2-factor problems

**Test Case 2 Finite Difference Method**

‚Ä¢ One-factor plain options

‚Ä¢ Euler, Crank-Nicolson methods

‚Ä¢ The ADE (Alternating Direction Explicit) method

‚Ä¢ Early exercise features

‚Ä¢ FDM for the CIR pde

‚Ä¢ Comparison of different methods

**Test Case 3 Lattice Methods**

‚Ä¢ The one-factor binomial and trinomial methods

‚Ä¢ Two-factor binomial method

‚Ä¢ Early exercise

‚Ä¢ Comparison with FD schemes

**Test Case 4 Exact and quasi-Exact Methods**

‚Ä¢ Exact Black Scholes price and greeks9

‚Ä¢ Barone-Whaley

‚Ä¢ Noncentral chiSquared distribution

‚Ä¢ Bonds, swaps and swaptions


